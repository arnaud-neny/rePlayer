/*
*   Copyright (C) 2022 Juergen Wothke
*   Copyright (C) original x86 code: Shortcut Software Development BV
*
* LICENSE
*
*   This software is licensed under a CC BY-NC-SA
*   (http://creativecommons.org/licenses/by-nc-sa/4.0/).
*/


// todo: there are quite a few functions here that would benefit from
// a refactoring and renaming of vars..

// known limitation: the generated "tmp cache sample files" are not yet
// 100% identical to the ones generated by the original player.. it seems to
// be some kind of rounding issue and the respective logic should eventually
// be improved (ftoi vs round?)

#include "Module.h"

#include <stdio.h>
#include <math.h>

#include "Packer.h"
#include "PlayerCore.h"
#include "File0.h"


#ifndef EMSCRIPTEN
// The web version cannot use the "costly" generator logic synchronously since
// that would block the browser - making the UI unresponsive. In the emscripten
// build the respective logic is therefore decoupled from the main player and
// put into a separate "Worker". Also respective "tmp" files used for cached
// samples are not stored in the FS but in the browser's DB.
#include "WaveGen.h"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#else
static char MSG_BUFFER[256]; // only used for short messages
// defined in callback.js
extern "C" void JS_printStatus(char *msg);

#endif

namespace IXS {

  const char *IXS_s_CRASH_WAV_004386e0 = "CRASH.WAV";
  const char *IXS_s_9SD_WAV_004386ec = "909SD.WAV";
  const char *IXS_s_9OH_WAV_00438700 = "909OH.WAV";

  // WAV sample-files bundled with the original player
  extern "C" const unsigned char WAVE_800[3424];
  extern "C" const unsigned char WAVE_801[3413];
  extern "C" const unsigned char WAVE_802[16098];

  // instance/class vars
  float IXS_loadTotalLen_0043b898;
  float *IXS_ptrProgress_0043b89c;
  uint IXS_loadProgressCount_0043b8a0;

  // "private methods"
  int __thiscall IXS__Module__loadIxsInputFileData_0x407db0(Module *module, byte *inputBuffer, FileSFXI *smplFile, FileSFXI *tmpFile);
  int __thiscall IXS__Module__readImpulseTrackerData_0x408450(Module *module, byte *itFileHead, FileSFXI *smplCacheFile);
  char __thiscall IXS__Module__loadImpulseTrackerFileData_00408b40(Module *module, byte *inputFileBuffer, uint unused);
  void __thiscall IXS__Module__readSample_IT_00409100(Module *module, int sampleIdx);
  void __thiscall IXS__Module__skipInput_004092d0(Module *module, byte *inputFileBuffer, int offset);
  byte *__thiscall IXS__Module__copyFromInputFile_004092f0(Module *module, void *dest, uint len);
  void __thiscall IXS__Module__copyFromInputFile_00409370(Module *module, void *dest, uint len);
  byte __thiscall IXS__Module__readByte_0x409320(Module *module);
  ushort __thiscall IXS__Module__readShort_0x409330(Module *module);
  uint __thiscall IXS__Module__readInt_0x409350(Module *module);
  void __thiscall IXS__Module__writeByte_00409390(Module *module, byte value);
  void __thiscall IXS__Module__writeShort_004093b0(Module *module, ushort value);
  void __thiscall IXS__Module__writeInt_004093d0(Module *module, int value);
  void __thiscall IXS__Module__writeBytes_004093f0(Module *module, byte *sourceBuf, uint len);

#ifdef EMSCRIPTEN
  extern "C" uint JS_getCacheFileData(char *filename, byte *dataBuf1, uint lenBuf1, byte *dataBuf2, uint lenBuf2, byte *destination);
  uint IXS__Module__loadSongFromCache(byte *cacheData, Module *module, byte *itFileHead);
#else
  uint IXS__Module__loadSongFromCache(const std::string &filename, Module *module, byte *itFileHead, FileSFXI *smplFile);
#endif

  typedef struct Body64x5 Body64x5;
  struct Body64x5 {
    struct Chan5 blocks[64];
  };

  typedef struct Head64 Head64;
  struct Head64 {
    // todo: model content of the "array"
    // 0: maskvariable

    byte byteArray_0x0[64];
  };

  typedef struct StackStruct384 StackStruct384;
  struct StackStruct384 {
    struct Head64 head;
    struct Body64x5 body;
  };


  void __fastcall IXS__Module__initChannelBlock_00406380(Channel *chnl) {
    Buf0x40 &buf40 = (chnl->subBuf80).buf40_0x10;
    buf40.byte_0x28 = 0;
    buf40.byte_0x29 = 0;
    buf40.byte_0x2a = 0;
    buf40.byte_0x2d = 1;
    buf40.uint_0x3c.b1 = 0;
  }





  Module *__thiscall IXS__Module__setPlayerCoreObj_00407b80(Module *module, PlayerCore *core) {
    module->ptrClassA_0xfae0 = core;
    IXS__Module__clearVars_00407ba0(module);
    return module;
  }


  void __thiscall IXS__Module__clearVars_00407ba0(Module *module) {
    module->insPtrArray_0xcc = (ITInstrument **) nullptr;
    module->smplHeadPtrArr0_0xd0 = (ITSample **) nullptr;
    module->smplDataPtrArr_0xd4 = (byte **) nullptr;
    module->patHeadPtrArray_0xd8 = (ITPatternHead **) nullptr;
    module->patDataPtrArray_0xdc = (byte **) nullptr;
    module->readPosition_0xc0 = (byte *) nullptr;
    module->ordersBuffer_0xc8 = (byte *) nullptr;

    // dead var: code to delete this buffer - but none to allocate it..
    module->someBufferPtr_0xc4 = nullptr;
  }


  void __fastcall IXS__Module__dtor_00407bf0(Module *module) {
    int i;

    if (module->ordersBuffer_0xc8 != (byte *) nullptr) {
      operator delete(module->ordersBuffer_0xc8);
    }
    if (module->insPtrArray_0xcc != (ITInstrument **) nullptr) {
      i = 0;
      if ((module->impulseHeader_0x0).InsNum_0x22 != 0) {
        do {
          operator delete(module->insPtrArray_0xcc[i]);
          i = i + 1;
        } while (i < (int) (uint) (module->impulseHeader_0x0).InsNum_0x22);
      }
      operator delete(module->insPtrArray_0xcc);
    }
    if (module->smplHeadPtrArr0_0xd0 != (ITSample **) nullptr) {
      i = 0;
      if ((module->impulseHeader_0x0).SmpNum_0x24 != 0) {
        do {
          operator delete(module->smplHeadPtrArr0_0xd0[i]);
          i = i + 1;
        } while (i < (int) (uint) (module->impulseHeader_0x0).SmpNum_0x24);
      }
      operator delete(module->smplHeadPtrArr0_0xd0);
    }
    if (module->smplDataPtrArr_0xd4 != (byte **) nullptr) {
      i = 0;
      if ((module->impulseHeader_0x0).SmpNum_0x24 != 0) {
        do {
          operator delete(module->smplDataPtrArr_0xd4[i]);
          i = i + 1;
        } while (i < (int) (uint) (module->impulseHeader_0x0).SmpNum_0x24);
      }
      operator delete(module->smplDataPtrArr_0xd4);
    }
    if (module->patHeadPtrArray_0xd8 != (ITPatternHead **) nullptr) {
      i = 0;
      if ((module->impulseHeader_0x0).PatNum_0x26 != 0) {
        do {
          operator delete(module->patHeadPtrArray_0xd8[i]);
          i = i + 1;
        } while (i < (int) (uint) (module->impulseHeader_0x0).PatNum_0x26);
      }
      operator delete(module->patHeadPtrArray_0xd8);
    }
    if (module->patDataPtrArray_0xdc != (byte **) nullptr) {
      i = 0;
      if ((module->impulseHeader_0x0).PatNum_0x26 != 0) {
        do {
          operator delete(module->patDataPtrArray_0xdc[i]);
          i = i + 1;
        } while (i < (int) (uint) (module->impulseHeader_0x0).PatNum_0x26);
      }
      operator delete(module->patDataPtrArray_0xdc);
    }
    if (module->someBufferPtr_0xc4 != nullptr) {
      operator delete((void *) module->someBufferPtr_0xc4);
    }
    IXS__Module__clearVars_00407ba0(module);
  }


  char __thiscall IXS__Module__loadSongFileData_00407d60(Module *module, byte *inputFileBuf,
                     uint fileSize, FileSFXI *alwaysNull, FileSFXI *tmpFile, float *loadProgressFeedbackPtr) {

    if (fileSize > 0xc0) {
      // todo: original impl completely ignores fileSize potentially causing ugly buffer overruns..

      module->optFileIXFS_0xfae4 = alwaysNull;
      IXS_ptrProgress_0043b89c = loadProgressFeedbackPtr;
      IXS_loadProgressCount_0043b8a0 = 0;
      module->readPosition_0xc0 = (byte *) inputFileBuf;

      if (*(uint *) inputFileBuf == 0x21535849) {   // check magic: "IXS!"
        return IXS__Module__loadIxsInputFileData_0x407db0(module, inputFileBuf, alwaysNull,  tmpFile);
      }
      // capable to load & play *some* original IT files (see pacmania.it or paranoia.it)
      return IXS__Module__loadImpulseTrackerFileData_00408b40(module, inputFileBuf, fileSize);
    } else {
      fprintf(stderr, "error: corrupted input file\n");
      return 1;
    }
  }

  uint genTmpFileId(const char *songTitleBuffer) {
    // original garbage impl used to get a "unique" name for the tmp-file
    // (it doesn't even work for the few song-files in existence! leading to
    // songs loading the wrong files and then crashing miserably)
    // just keeping this for compatibility with the original player..

    uint iVar4 = 0xffffffff;
    uint iVar8;
    uint local_10;
    // ptr to "song title"
    const char *pcVar3 = songTitleBuffer;
    uint uUnique;
    char cVar1;
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 - 1;
      cVar1 = *pcVar3;
      pcVar3 = pcVar3 + 1;
    } while (cVar1 != '\0');
    // len of songname
    local_10 = ~iVar4 - 1;
    iVar4 = local_10;

    if ((int) local_10 < 1) {
      LAB_00407ed5:
      uUnique = 0xdeadbeef;
    } else {
      do {
        uUnique = 0;
        iVar8 = local_10;
        byte *puVar9 = (byte *) songTitleBuffer;
        do {
          byte bVar2 = (byte) iVar8 & 0x1f;
          uUnique = uUnique ^ ((uint) *puVar9 << bVar2 | (uint) (*puVar9 >> (0x20 - bVar2)));
          puVar9 = puVar9 + 1;
          iVar8 = iVar8 - 1;
        } while (iVar8 != 0);
        iVar4 = iVar4 - 1;
      } while (iVar4 != 0);

      if (uUnique == 0) goto LAB_00407ed5;
    }
    return uUnique;
  }



  std::string IXS__Module__getTempFileName(const char *songname) {
    uint uUnique = genTmpFileId(songname);

#if 1//!defined(EMSCRIPTEN) && !defined(LINUX)
    char pathBuffer[260];
    GetTempPathA(0x104, pathBuffer);
    // get a specific ".tmp" file name for each song
    char fileNameBuffer[260];
    GetTempFileNameA(pathBuffer, "IXS", uUnique, fileNameBuffer);
#else
    char fileNameBuffer[260];
    sprintf(fileNameBuffer, "songs/IXS%4X.tmp", uUnique);
#endif
    return fileNameBuffer;
  }


#ifndef EMSCRIPTEN
  // impl used in the original player - using %TEMP% folder based file to synchronously create/load a cache file
  int __thiscall loadIxsInputFileData(Module *module, std::string filename, byte *itFileHead, byte *dataBuf1, uint lenBuf1,
                                      byte *dataBuf2, uint lenBuf2, float outputVolume, FileSFXI *smplFile, FileSFXI *tmpFile) {
    FileMap *fileMap = nullptr;
    FileSFXI *fileSFXI = nullptr;

/*
    if (tmpFile == nullptr) {
      if (smplFile == nullptr) {
        // check for existing cache file
        File0 *cacheFile = IXS__File__Z_ctor_FUN_004138e0();
        fileMap = (*cacheFile->vftable->initFileMap)(cacheFile, (char*)filename.c_str());
        delete cacheFile;

        if (fileMap == (FileMap *) nullptr) {
          fprintf(stderr, "no cache file found: [%s]\n", filename.c_str());

          IXS__WAVEGEN__createSampleCacheFile((char*)filename.c_str(), dataBuf1, dataBuf2, nullptr);
        } else {
          fprintf(stderr, "found cache file: [%s]\n", filename.c_str());
          (*fileMap->vftable->delete0)(fileMap);
        }
      }

    } else {  // untested scenario
      IXS__WAVEGEN__createSampleCacheFile((char*)filename.c_str(), dataBuf1, dataBuf2, tmpFile);
    }
*/
    fileSFXI = IXS__WAVEGEN__createSampleCacheFile((char*)filename.c_str(), dataBuf1, dataBuf2, nullptr);

    auto* buf = fileSFXI->buffer_0x4;
    if(IXS__Module__loadSongFromCache(filename, module, itFileHead, fileSFXI)) {
      free(buf);
      fprintf(stderr, "error: invalid IT file\n");
      return 1;
    }
    free(buf);

    module->ptrClassA_0xfae0->ptrMixer_0x3224->outputVolume_0x24 = outputVolume;
    return 0;
  }


#else
// the calling code expects this function to work synchronously.. while all the
// APIs available in the Web context actually work asynchronously. A "fail & retry approach" is
// therefore used here: until a result can actually be delivered synchronously, this function
// will return -1 which the WebAudio player code interprets as "waiting for async result". When
// a respective result later does become available, it is separately cached so that it can then
// be delivered "synchronously" when the WebAudio player retries to call the same below code
// for a second time.. the async handling would be a nightmare here so the complete function
// is forwarded to the JavaScript side..

  byte *sCacheFileTransferBuffer = 0;  // garbage needed due to silly Worker API and EMSCRIPTEN return value limitations

  int __thiscall loadIxsInputFileData(Module *module, std::string filename, byte *itFileHead, byte *dataBuf1, uint lenBuf1,
                                      byte *dataBuf2, uint lenBuf2, float outputVolume, FileSFXI *smplFile, FileSFXI *tmpFile) {

    uint bufSize= 33554432;
    if (sCacheFileTransferBuffer == nullptr) {
      sCacheFileTransferBuffer = (byte*)malloc(bufSize); // this should be big enough for all existing files
    }
    // the two input FileSFXI params are irrelevant in the web-player context and are therefore ignored..
     uint len = JS_getCacheFileData((char*)filename.c_str(), dataBuf1, lenBuf1, dataBuf2, lenBuf2, sCacheFileTransferBuffer);
    if (!len) {
      return -1;
    }
    if (len > bufSize) {
      fprintf(stderr, "ERROR: buffer too small! memory corruption already happend..");
      return 1;
    }

    // this must be a "retry" since data has been made synchronously available
    if(IXS__Module__loadSongFromCache(sCacheFileTransferBuffer, module, itFileHead)) {
      fprintf(stderr, "error: invalid IT file\n");
      return 1;
    }

    module->ptrClassA_0xfae0->ptrMixer_0x3224->outputVolume_0x24 = outputVolume;

    return 0;
  }

#endif


  int __thiscall IXS__Module__loadIxsInputFileData_0x407db0(Module *module, byte *inputBuffer, FileSFXI *smplFile,
                                                            FileSFXI *tmpFile) {

    module->readPosition_0xc0 = (byte *) inputBuffer;

    uint magic = IXS__Module__readInt_0x409350(module);
    if (magic != 0x21535849) { // "IXS!"
      fprintf(stderr,"error: not an IXS! file\n");
      return 1;
    }
    uint itHeadOffset = IXS__Module__readInt_0x409350(module);

    int offset1 = IXS__Module__readInt_0x409350(module);
    uint offset2 = IXS__Module__readInt_0x409350(module);
    uint packedLen = IXS__Module__readInt_0x409350(module);

    float outputVolume;
    IXS__Module__copyFromInputFile_00409370(module, &outputVolume, 4);

    char songTitle[32];
    IXS__Module__copyFromInputFile_00409370(module, songTitle, 0x20); // the "song title"

#ifndef EMSCRIPTEN
    fprintf(stderr, "loading: %s\n", songTitle);
#else
    sprintf(MSG_BUFFER, "loading: %s\n", songTitle);
    JS_printStatus(MSG_BUFFER);
#endif

    ByteArray *packedData = (ByteArray *) IXS__Packer__newByteArray_0040ce40();
    packedData->bufPtr_0x0 = (int *) module->readPosition_0xc0;
    packedData->bufSize_0x4 = packedLen;

    auto* oldPackedData = packedData;
    Packer *packer = IXS__Packer__ctor_0040cea0();
    packedData = (*packer->vftptr_0x0->fn2_inflate)(packer, packedData);
    int *inflatedData = packedData->bufPtr_0x0;

    // the inflatedData seems to be filled with 3 consecutive sections:
    byte *itFileHead = (byte *) ((uintptr_t) inflatedData + itHeadOffset);  // tracker data
    byte *dataBuf1 = (byte *) ((uintptr_t) inflatedData + offset1);         // input for "regular samples"
    byte *dataBuf2 = (byte *) ((uintptr_t) inflatedData + offset2);          // input for "synth samples"

    IXS_loadTotalLen_0043b898 = (float) ((int) (char) *dataBuf2 + *(int*)dataBuf1);

//     std::string filename= IXS__Module__getTempFileName(songTitle);

    int retVal= loadIxsInputFileData(module, "", itFileHead, dataBuf1, offset2 - offset1,
                                     dataBuf2, packedData->bufSize_0x4-offset2, outputVolume,
                                     smplFile, tmpFile);


    if (packer != (Packer *) nullptr) {
      free(packedData->bufPtr_0x0);
//       free(oldPackedData->bufPtr_0x0);
      free(packedData);
      free(oldPackedData);
      IXS__Packer__dtor_0x40ca60(packer);
      operator delete(packer);
    }
    return retVal;
  }

#ifndef EMSCRIPTEN
  uint IXS__Module__loadSongFromCache(const std::string &filename, Module *module, byte *itFileHead, FileSFXI *smplFile) {
    FileMap *cacheMap = (FileMap *) nullptr;
    if (smplFile == (FileSFXI *) nullptr) {
      File0 *cacheFile = IXS__File__Z_ctor_FUN_004138e0();
      cacheMap = (*cacheFile->vftable->initFileMap)(cacheFile, (char*)filename.c_str());
      smplFile = IXS__FileSFXI__FUN_00413c70(cacheMap);
      delete cacheFile;
    }
    uint retVal= 0;
    if(IXS__Module__readImpulseTrackerData_0x408450(module, itFileHead, smplFile)) {
      retVal = 1;
    }
    (*smplFile->vftptr_0x0->deleteObject)(smplFile);

    if (cacheMap != (FileMap *) nullptr) {
      (*cacheMap->vftable->delete0)(cacheMap);
    }
    return retVal;
  }
#else
  // load from memory buffer
  uint IXS__Module__loadSongFromCache(byte *cacheData, Module *module, byte *itFileHead) {
    FileSFXI *smplFile = IXS__FileSFXI__newFileSFXI_00413c20((BufSFXI*)cacheData);

    uint retVal = 0;
    if(IXS__Module__readImpulseTrackerData_0x408450(module, itFileHead, smplFile)) {
      retVal = 1;
    }
    (*smplFile->vftptr_0x0->deleteObject)(smplFile);
    return retVal;
  }
#endif

  int __thiscall IXS__Module__readImpulseTrackerData_0x408450(Module *module, byte *itFileHead, FileSFXI *smplCacheFile) {

    module->readPosition_0xc0 = itFileHead;

    if ((byte) IXS__Module__readByte_0x409320(module) != 33) {
      return 1;
    }
    module->impulseHeader_0x0.OrdNum_0x20 = IXS__Module__readShort_0x409330(module);
    module->impulseHeader_0x0.InsNum_0x22 = IXS__Module__readShort_0x409330(module);
    module->impulseHeader_0x0.SmpNum_0x24 = IXS__Module__readShort_0x409330(module);
    module->impulseHeader_0x0.PatNum_0x26 = IXS__Module__readShort_0x409330(module);
    module->impulseHeader_0x0.GV_0x30 = IXS__Module__readByte_0x409320(module);
    module->impulseHeader_0x0.MV_0x31 = IXS__Module__readByte_0x409320(module);
    module->impulseHeader_0x0.Speed_0x32 = IXS__Module__readByte_0x409320(module);
    module->impulseHeader_0x0.Tempo_0x33 = IXS__Module__readByte_0x409320(module);

    IXS__Module__copyFromInputFile_00409370(module, module->impulseHeader_0x0.songName_0x4, 0x1A);

    IXS__Module__copyFromInputFile_00409370(module, module->impulseHeader_0x0.ChnlVol_0x80, 0x40);
    IXS__Module__copyFromInputFile_00409370(module, module->impulseHeader_0x0.ChnlPan_0x40, 0x40);
    byte *ordBuf = (byte *) malloc(module->impulseHeader_0x0.OrdNum_0x20);
    module->ordersBuffer_0xc8 = ordBuf;
    IXS__Module__copyFromInputFile_00409370(module, ordBuf, module->impulseHeader_0x0.OrdNum_0x20);

    ITInstrument **ins0 = (ITInstrument **) malloc(sizeof(ITInstrument*) * module->impulseHeader_0x0.InsNum_0x22);
    int i1 = 0;
    ushort num = module->impulseHeader_0x0.InsNum_0x22 == 0;
    module->insPtrArray_0xcc = ins0;
    int i2 = 0;
    if (!num) {
      do {
        module->insPtrArray_0xcc[i1] = (ITInstrument *) malloc(sizeof(ITInstrument));
        ITInstrument *ins1 = module->insPtrArray_0xcc[i1];
        memset(ins1, 0, sizeof(ITInstrument));
        if ((byte) IXS__Module__readByte_0x409320(module) == 'i') {
          byte *kbPtr0 = &ins1->keyboard_0x40[1];
          int n = 120;
          do {
            *kbPtr0 = 0;
            kbPtr0 += 2;
            --n;
          } while (n);
        } else {
          ins1->fadeout_0x14 = IXS__Module__readShort_0x409330(module);

          ins1->gbv_0x18 = IXS__Module__readByte_0x409320(module);
          ins1->dfp_0x19 = IXS__Module__readByte_0x409320(module);
          ins1->keyboard_0x40[0] = IXS__Module__readByte_0x409320(module);
          char b = IXS__Module__readByte_0x409320(module);
          ins1->keyboard_0x40[1] = b;
          if (b >= 0) {
            IXS__Module__copyFromInputFile_00409370(module, &ins1->keyboard_0x40[2], 238);
          } else {
            byte *kbPtr = &ins1->keyboard_0x40[3];
            ins1->keyboard_0x40[1] = b & 0x7F;
            for (int i = 1; i < 120; ++i) {
              *(kbPtr - 1) = i;
              *kbPtr = ins1->keyboard_0x40[1];
              kbPtr += 2;
            }
          }

          ITEnvelope *envArray[3];
          envArray[0] = &ins1->volenv_0x130;
          envArray[1] = &ins1->panenv_0x182;
          envArray[2] = &ins1->pitchenv_0x1d4;

          int s = 3;
          do {
            ITEnvelope *envPtr = envArray[3 - s];
            byte flags = IXS__Module__readByte_0x409320(module);

            envPtr->flags_0x0 = flags;

            if (flags) {
              envPtr->numNP_0x1 = IXS__Module__readByte_0x409320(module);
              envPtr->lpb_0x2 = IXS__Module__readByte_0x409320(module);
              envPtr->lpe_0x3 = IXS__Module__readByte_0x409320(module);
              envPtr->slb_0x4 = IXS__Module__readByte_0x409320(module);
              envPtr->sle_0x5 = IXS__Module__readByte_0x409320(module);
              IXS__Module__copyFromInputFile_00409370(module, envPtr->nodePoints_0x6, (uint) envPtr->numNP_0x1 * 3);
            }
            --s;
          } while (s);
          i1 = i2;
        }
        i2 = ++i1;
      } while (i1 < module->impulseHeader_0x0.InsNum_0x22);
    }
    module->smplHeadPtrArr0_0xd0 = (ITSample **) malloc(sizeof(ITSample*) * module->impulseHeader_0x0.SmpNum_0x24);
    module->smplDataPtrArr_0xd4 = (byte **) malloc(sizeof(byte*) * module->impulseHeader_0x0.SmpNum_0x24);

    int smplIdx = 0;
    num = module->impulseHeader_0x0.SmpNum_0x24 == 0;

    int idx = 0;
    if (!num) {
      do {
        module->smplHeadPtrArr0_0xd0[smplIdx] = (ITSample *) malloc(sizeof(ITSample));
        module->smplDataPtrArr_0xd4[smplIdx] = 0;
        ITSample *smplHeadPtr = module->smplHeadPtrArr0_0xd0[smplIdx];
        memset(smplHeadPtr, 0, sizeof(ITSample));

        char s = (char) IXS__Module__readByte_0x409320(module);
        if (s == 's') {
          smplHeadPtr->flags_0x12 = 0;
        } else {
          smplHeadPtr->gvl_0x11 = IXS__Module__readByte_0x409320(module);
          smplHeadPtr->flags_0x12 = IXS__Module__readByte_0x409320(module);
          smplHeadPtr->volume_0x13 = IXS__Module__readByte_0x409320(module);
          smplHeadPtr->length_0x30 = IXS__Module__readInt_0x409350(module);
          smplHeadPtr->loopBegin_0x34 = IXS__Module__readInt_0x409350(module);
          smplHeadPtr->loopEnd_0x38 = IXS__Module__readInt_0x409350(module);
          smplHeadPtr->susLoopBegin_0x40 = IXS__Module__readInt_0x409350(module);
          smplHeadPtr->susLoopEnd_0x44 = IXS__Module__readInt_0x409350(module);
          smplHeadPtr->C5Speed_0x3c = IXS__Module__readInt_0x409350(module);
          smplHeadPtr->vis_0x4c = IXS__Module__readByte_0x409320(module);
          smplHeadPtr->vid_0x4d = IXS__Module__readByte_0x409320(module);
          smplHeadPtr->vir_0x4e = IXS__Module__readByte_0x409320(module);
          smplHeadPtr->vit_0x4f = IXS__Module__readByte_0x409320(module);
          smplHeadPtr->dfp_0x2f = IXS__Module__readByte_0x409320(module);
          IXS__Module__copyFromInputFile_00409370(module, smplHeadPtr->filename_0x4, 13);

          ITSample *smplHead0 = module->smplHeadPtrArr0_0xd0[smplIdx];
          size_t smplLen = smplHead0->length_0x30;
          byte flags = smplHead0->flags_0x12;

          uint len = smplLen;
          if ((flags & IT_16BIT) != 0) {
            smplLen *= 2;
            len = smplLen;
          }
          if ((flags & IT_STEREO) != 0) {
            fprintf(stderr, "no stereo sams allowed\n");
          }
          if (!module->ptrClassA_0xfae0->isMMOutDisabled_0x0) {
            module->smplDataPtrArr_0xd4[smplIdx] = (byte *) malloc(smplLen);
            if (smplCacheFile) {
              char sampleNameBuf[14];

              strncpy(sampleNameBuf, module->smplHeadPtrArr0_0xd0[smplIdx]->filename_0x4, 13);
#ifndef EMSCRIPTEN
//              fprintf(stderr, "   use cached: %s len: %d\n", module->smplHeadPtrArr0_0xd0[smplIdx]->filename_0x4, smplLen);
#else
    std::string sampleName= std::string(module->smplHeadPtrArr0_0xd0[smplIdx]->filename_0x4,
                                        strlen(module->smplHeadPtrArr0_0xd0[smplIdx]->filename_0x4) - 4); // cut off ".WAV"
    sprintf(MSG_BUFFER, "   load: %s\n",  sampleName.c_str());
    JS_printStatus(MSG_BUFFER);
#endif

              bool alreadyDone = false;
              if (!strcmp(sampleNameBuf, IXS_s_9OH_WAV_00438700)) {
                alreadyDone = true;

                // testcase: "vixen - heineken" seems to actually use these..
                smplHead0->length_0x30 = 3424; // original code fucked this up..
                module->smplDataPtrArr_0xd4[smplIdx] = (byte *) realloc(module->smplDataPtrArr_0xd4[smplIdx],
                                                                        smplHead0->length_0x30);

                memcpy(module->smplDataPtrArr_0xd4[smplIdx], (const void *) WAVE_800, smplHead0->length_0x30);
              }
              if (!strcmp(sampleNameBuf, IXS_s_9SD_WAV_004386ec)) {
                alreadyDone = true;
                smplHead0->length_0x30 = 3413;
                module->smplDataPtrArr_0xd4[smplIdx] = (byte *) realloc(module->smplDataPtrArr_0xd4[smplIdx],
                                                                        smplHead0->length_0x30);

                memcpy(module->smplDataPtrArr_0xd4[smplIdx], (const void *) WAVE_801, smplHead0->length_0x30);
              }
              if (!strcmp(sampleNameBuf, IXS_s_CRASH_WAV_004386e0)) {
                smplHead0->length_0x30 = 16098;
                module->smplDataPtrArr_0xd4[smplIdx] = (byte *) realloc(module->smplDataPtrArr_0xd4[smplIdx],
                                                                        smplHead0->length_0x30);

                memcpy(module->smplDataPtrArr_0xd4[smplIdx], (const void *) WAVE_802, smplHead0->length_0x30);
              } else if (!alreadyDone) {
                FileMapSFXI *mapSFXI = (smplCacheFile->vftptr_0x0->newMapSFXI)(smplCacheFile, sampleNameBuf);
                if (mapSFXI) {
                  memcpy(module->smplDataPtrArr_0xd4[idx], mapSFXI->vftable->getMemBuffer(mapSFXI), len);
                  ITSample *smplHead = module->smplHeadPtrArr0_0xd0[idx];
                  smplHead->flags_0x12 &= ~(IT_COMPRESSED);
                  mapSFXI->vftable->deleteObj(mapSFXI);
                } else {
                  fprintf(stderr,
                          "Itmodule.cpp: void TModule::ReadSample(int cnt)\n\nError opening file:  '%s'\n",
                          sampleNameBuf);
                }
                smplIdx = idx;
              }
            }
          }
        }
        idx = ++smplIdx;
      } while (smplIdx < module->impulseHeader_0x0.SmpNum_0x24);
    }
    module->patHeadPtrArray_0xd8 = (ITPatternHead **) malloc(sizeof(ITPatternHead) * module->impulseHeader_0x0.PatNum_0x26);
    byte **patDataPtrArray = (byte **) malloc(sizeof(byte*) * module->impulseHeader_0x0.PatNum_0x26);
    module->patDataPtrArray_0xdc = patDataPtrArray;

    int ii = 0;
    num = module->impulseHeader_0x0.PatNum_0x26 == 0;
    module->lastOrder_0xfaec = -1;
    if (!num) {
      do {
        module->patHeadPtrArray_0xd8[ii] = (ITPatternHead *) malloc(sizeof(ITPatternHead));
        ITPatternHead *patHeadPtr = module->patHeadPtrArray_0xd8[ii];
        module->patDataPtrArray_0xdc[ii] = 0;
        if ((byte) IXS__Module__readByte_0x409320(module) != 'p') {
          patHeadPtr->len_0x0 = IXS__Module__readShort_0x409330(module);
          patHeadPtr->rows_0x2 = IXS__Module__readShort_0x409330(module);
          module->patDataPtrArray_0xdc[ii] = (byte *) malloc(patHeadPtr->len_0x0);
          IXS__Module__copyFromInputFile_00409370(module, module->patDataPtrArray_0xdc[ii], patHeadPtr->len_0x0);
        }
        ++ii;
      } while (ii < module->impulseHeader_0x0.PatNum_0x26);
    }
    return 0;
  }

  char __thiscall
  IXS__Module__loadImpulseTrackerFileData_00408b40(Module *module, byte *inputFileBuffer, uint fileSize) {

    module->readPosition_0xc0 = (byte *) inputFileBuffer;
    IXS__Module__copyFromInputFile_004092f0(module, module, 0xc0);
    ImpulseHeaderStruct &itHeader = module->impulseHeader_0x0;
    size_t magic = itHeader.magic_0x0;

    if (magic != 0x4d504d49) {  // check magic: "IMPM"
      fprintf(stderr, "error: unknown input file format\n");
      return 1;
      // what's this garbage? allocating a random buffer based on the 1st int
      // of some file?? (at least it is deleted at the end of the func)
//      inputFileBuffer = (byte *) malloc(magic);
//      module->readPosition_0xc0 = (byte *) inputFileBuffer;
//      IXS__Module__copyFromInputFile_004092f0(module, module, 0xc0);
    }

    if ((itHeader.Flags_0x2c & 4) == 0) {
      // i.e. songs with samples not supported
      fprintf(stderr, "non-instrument it-files not allowed!!\n");
      return 1;
    }
    byte *pSrc = (byte *) malloc((uint) itHeader.OrdNum_0x20);
    ushort ordNum = itHeader.OrdNum_0x20;
    module->ordersBuffer_0xc8 = pSrc;
    IXS__Module__copyFromInputFile_004092f0(module, pSrc, (uint) ordNum);

    int *insOffsets = (int *) malloc((uint) itHeader.InsNum_0x22 << 2);
    int *smplOffsets = (int *) malloc((uint) itHeader.SmpNum_0x24 << 2);
    int *patOffsets = (int *) malloc((uint) itHeader.PatNum_0x26 << 2);

    IXS__Module__copyFromInputFile_004092f0(module, insOffsets, (uint) itHeader.InsNum_0x22 << 2);
    IXS__Module__copyFromInputFile_004092f0(module, smplOffsets, (uint) itHeader.SmpNum_0x24 << 2);
    IXS__Module__copyFromInputFile_004092f0(module, patOffsets, (uint) itHeader.PatNum_0x26 << 2);

    ushort insNum = itHeader.InsNum_0x22;
    module->insPtrArray_0xcc = (ITInstrument **) malloc((uint) itHeader.InsNum_0x22 * sizeof(ITInstrument*));
    if (insNum != 0) {
      int i = 0;
      do {
        module->insPtrArray_0xcc[i] = (ITInstrument *) malloc(sizeof(ITInstrument));
        ITInstrument *ins = module->insPtrArray_0xcc[i];

        IXS__Module__skipInput_004092d0(module, inputFileBuffer, insOffsets[i]);
        IXS__Module__copyFromInputFile_004092f0(module, ins, 0x22d);

        int k = 0;
        do {
          (ins->panenv_0x182).nodePoints_0x6[k] += 0x20;
          (ins->pitchenv_0x1d4).nodePoints_0x6[k] += 0x20;
          k += 3;
        } while (k < 75);
        i = i + 1;
      } while (i < (int) (uint) itHeader.InsNum_0x22);
    }

    module->smplHeadPtrArr0_0xd0 = (ITSample **) malloc((uint) itHeader.SmpNum_0x24 * sizeof(ITSample*));
    byte **smplDataPtrArray = (byte **) malloc((uint) itHeader.SmpNum_0x24 * sizeof(byte*));
    ushort smplNum = itHeader.SmpNum_0x24;
    module->smplDataPtrArr_0xd4 = smplDataPtrArray;
    if (smplNum != 0) {
      int i = 0;
      do {
        module->smplHeadPtrArr0_0xd0[i] = (ITSample *) malloc(sizeof(ITSample));
        ITSample *smpl = module->smplHeadPtrArr0_0xd0[i];

        module->smplDataPtrArr_0xd4[i] = (byte *) nullptr;

        IXS__Module__skipInput_004092d0(module, inputFileBuffer, smplOffsets[i]);
        IXS__Module__copyFromInputFile_004092f0(module, smpl, 0x50);
        if ((smpl->length_0x30 != 0) &&
            ((smpl->flags_0x12 & IT_SMPL) != 0)) {
          module->smplDataPtrArr_0xd4[i] = (byte *) nullptr;
          IXS__Module__skipInput_004092d0(module, inputFileBuffer, smpl->samplePointer_0x48);
          IXS__Module__readSample_IT_00409100(module, i);
        }
        i = i + 1;
      } while (i < (int) (uint) itHeader.SmpNum_0x24);
    }

    module->patHeadPtrArray_0xd8 = (ITPatternHead **) malloc((uint) itHeader.PatNum_0x26 * sizeof(ITPatternHead*));
    ushort patNum = itHeader.PatNum_0x26;
    module->patDataPtrArray_0xdc = (byte **) malloc((uint) itHeader.PatNum_0x26 * sizeof(byte*));;
    module->lastOrder_0xfaec = -1;
    if (patNum != 0) {
      int i = 0;
      do {
        module->patHeadPtrArray_0xd8[i] = (ITPatternHead *) malloc(sizeof(ITPatternHead));
        ITPatternHead *patHead = module->patHeadPtrArray_0xd8[i];

        if (patOffsets[i] != 0) {
          IXS__Module__skipInput_004092d0(module, inputFileBuffer, patOffsets[i]);
          IXS__Module__copyFromInputFile_004092f0(module, patHead, 8);

          module->patDataPtrArray_0xdc[i] = (byte *) malloc((uint) patHead->len_0x0);

          IXS__Module__copyFromInputFile_004092f0(module, module->patDataPtrArray_0xdc[i],
                                                  (uint) patHead->len_0x0);
        } else {
          module->patDataPtrArray_0xdc[i] = (byte *) nullptr;
        }
        i = i + 1;
      } while (i < (int) itHeader.PatNum_0x26);
    }
    if (magic != 0x4d504d49) {  // "IMPM"
      free(inputFileBuffer);
    }

    // was missing in original code
    free(patOffsets);
    free(smplOffsets);
    free(insOffsets);

    return 0;
  }


  IntBuffer16k *__thiscall IXS__Module__update16Kbuf_00408ec0(Module *module, int order) {
    StackStruct384 local_180;

    if (module->lastOrder_0xfaec == order) {
      return &module->buf16k_0xe0;
    }
    module->lastOrder_0xfaec = order;

    IntBuffer16k *buf16k = &module->buf16k_0xe0;
    ITPatternHead *patHead = module->patHeadPtrArray_0xd8[order];
    byte *patData = module->patDataPtrArray_0xdc[order];

    memset(buf16k->buf_0x0, 0, 16000 * 4);  // todo: probably 1000 * 64

    int i;

    if (patData != (byte *) nullptr) {
      i = 0;
      if (patHead->rows_0x2 != 0) {
        char *dest = (char *) ((uintptr_t) (module->buf16k_0xe0).buf_0x0 + 2);
        do {
          *dest = -1;
          i = i + 1;
          dest = dest + 5;
        } while (i < (int) ((uint) patHead->rows_0x2 * 0x40));
        // todo: with max 200 rows a 12800 bytes buffer should be big enough.. why 4*16k?
        // what is in the remaining 51200 bytes?
      }

      memset(&local_180, 0, sizeof(local_180)); //  also avoids the unaligned mem access issues..

      // struct area that is initialized to -1
      // area 0x13e (64*5step =0x140 area)
      char *bDest = &local_180.body.blocks[0].vol_pan_0x2;
      i = 0x40;
      do {
        *bDest = -1;
        bDest = bDest + 5;
        i = i + -1;
      } while (i != 0);

      uint j = 0;
      uint k = 0;
      i = 0;
      do {
        int i1 = i + 1;

        // GetNextChannelMarker:  Read byte into channelvariable.
        if (patData[i] == 0) {
          // end of row
          j = j + 1;
          k = k + 0x40;
        } else {
          uint channel = (uint) (patData[i] - 1 & 63);
          module->channels |= 1ull << channel;
          int idx = i1;
          if ((patData[i] & 0x80) != 0) {
            // if(channelvariable & 128) then read byte into maskvariable
            idx = i + 2;
            local_180.head.byteArray_0x0[channel] = patData[i1];
          }
          i = k + channel;

          byte b;
          if ((local_180.head.byteArray_0x0[channel] & 1) != 0) {
            // if(maskvariable & 1), then read note. (byte value)
            // Note ranges from 0->119 (C-0 -> B-9)
            // 255 = note off, 254 = notecut
            // Others = note fade (already programmed into IT's player
            //                     but not available in the editor)

            b = patData[idx];
            idx = idx + 1;
            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5) = b;
            ((Body64x5 *) (&local_180.head + 1))->blocks[channel].note_0x0 = b;
          }
          if ((local_180.head.byteArray_0x0[channel] & 2) != 0) {
            // if(maskvariable & 2), then read instrument (byte value)
            // Instrument ranges from 1->99

            b = patData[idx];
            idx = idx + 1;
            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 1) = b;
            ((Body64x5 *) (&local_180.head + 1))->blocks[channel].numIns_0x1 = b;
          }
          if ((local_180.head.byteArray_0x0[channel] & 4) != 0) {
            // if(maskvariable & 4), then read volume/panning (byte value)
            //                // Volume ranges from 0->64
            //                // Panning ranges from 0->64, mapped onto 128->192, etc

            char c = *(char *) &patData[idx];
            idx = idx + 1;
            *(char *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 2) = c;
            ((Body64x5 *) (&local_180.head + 1))->blocks[channel].vol_pan_0x2 = c;
          }
          i1 = idx;
          if ((local_180.head.byteArray_0x0[channel] & 8) != 0) {
            // if(maskvariable & 8), then read command (byte value) and commandvalue
            // Valid ranges from 0->31 (0=no effect, 1=A, 2=B, 3=C, etc.)


            i1 = idx + 2;
            b = patData[idx];
            ((Body64x5 *) (&local_180.head + 1))->blocks[channel].cmd_0x3 = b;
            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 3) = b;

            b = patData[idx + 1];
            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 4) = b;
            ((Body64x5 *) (&local_180.head + 1))->blocks[channel].cmdArg_0x4 = b;
          }
          if ((local_180.head.byteArray_0x0[channel] & 0x10) != 0) {
            // if(maskvariable & 16), then note = lastnote for channel

            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5) =
                    ((Body64x5 *) (&local_180.head + 1))->blocks[channel].note_0x0;
          }
          if ((local_180.head.byteArray_0x0[channel] & 0x20) != 0) {
            //  if(maskvariable & 32), then instrument = lastinstrument for channel
            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 1) =
                    ((Body64x5 *) (&local_180.head + 1))->blocks[channel].numIns_0x1;
          }
          if ((local_180.head.byteArray_0x0[channel] & 0x40) != 0) {
            // if(maskvariable & 64), then volume/pan = lastvolume/pan for channel
            *(char *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 2) =
                    ((Body64x5 *) (&local_180.head + 1))->blocks[channel].vol_pan_0x2;
          }
          if ((local_180.head.byteArray_0x0[channel] & 0x80) != 0) {
            //  if(maskvariable & 128), then {
            //          command = lastcommand for channel and
            //          commandvalue = lastcommandvalue for channel
            //  }

            b = ((Body64x5 *) (&local_180.head + 1))->blocks[channel].cmdArg_0x4;
            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 3) =
                    ((Body64x5 *) (&local_180.head + 1))->blocks[channel].cmd_0x3;
            *(byte *) ((uintptr_t) buf16k->buf_0x0 + i * 5 + 4) = b;
          }
        }
        i = i1;
      } while (j < patHead->rows_0x2);
      return buf16k;
    }
    return buf16k;
  }


  void __thiscall IXS__Module__readSample_IT_00409100(Module *module, int sampleIdx) {
    ITSample *smplHeadPtr = module->smplHeadPtrArr0_0xd0[sampleIdx];
    size_t smplLen = smplHeadPtr->length_0x30;

    byte flags = smplHeadPtr->flags_0x12;
    if ((flags & IT_16BIT) != 0) {
      smplLen *= 2;
    }
    if ((flags & IT_STEREO) != 0) {
      fprintf(stderr, "no stereo sams allowed..\n");
    }
    if (module->ptrClassA_0xfae0->isMMOutDisabled_0x0) {
      module->smplDataPtrArr_0xd4[sampleIdx] = nullptr;
      module->readPosition_0xc0 += smplLen;

    } else {
      module->smplDataPtrArr_0xd4[sampleIdx] = (byte *) malloc(smplLen);
      IXS__Module__copyFromInputFile_004092f0(module, module->smplDataPtrArr_0xd4[sampleIdx], smplLen);

      if (module->optFileIXFS_0xfae4) {
        static char SAMPLENAME_BUFFER[16];
        strncpy(SAMPLENAME_BUFFER, module->smplHeadPtrArr0_0xd0[sampleIdx]->filename_0x4, 13);
        SAMPLENAME_BUFFER[13] = 0;

        FileSFXI *optFileIXFS = module->optFileIXFS_0xfae4;
        FileMapSFXI *mapSFXI = (optFileIXFS->vftptr_0x0->newMapSFXI)(optFileIXFS, SAMPLENAME_BUFFER);
        if (mapSFXI) {
          memcpy(module->smplDataPtrArr_0xd4[sampleIdx], mapSFXI->vftable->getMemBuffer(mapSFXI), smplLen);
          ITSample *smplHeadPtr1 = module->smplHeadPtrArr0_0xd0[sampleIdx];
          smplHeadPtr1->flags_0x12 &= ~(IT_COMPRESSED);

          mapSFXI->vftable->deleteObj(mapSFXI);
        } else {
          fprintf(stderr, "Itmodule.cpp: void TModule::ReadSample(int cnt)\n\nError opening file:  '%s'\n",
                  SAMPLENAME_BUFFER);
        }
      }
    }
    ITSample *smplHeadPtr2 = module->smplHeadPtrArr0_0xd0[sampleIdx];

    flags = smplHeadPtr2->flags_0x12;
    if ((flags & IT_COMPRESSED) != 0 && !module->ptrClassA_0xfae0->isMMOutDisabled_0x0) {
      // some delta-encoding? .. probably to improve compression
      if ((flags & IT_16BIT) != 0) {
        // 16-bit version
        int sSum = 0;
        short *smplDataPtr0 = (short *) module->smplDataPtrArr_0xd4[sampleIdx];
        for (uint i = 0; i < smplHeadPtr2->length_0x30; i++) {
          sSum += *smplDataPtr0++;
          smplDataPtr0[0] = (short) sSum;
        }
      } else {
        // 8-bit version
        byte *smplDataPtr = module->smplDataPtrArr_0xd4[sampleIdx];
        if (smplHeadPtr2->length_0x30) {
          byte bSum = 0;
          uint i = 0;
          do {
            bSum += smplDataPtr[i];
            smplDataPtr[i++] = bSum;
          } while (i < smplHeadPtr2->length_0x30);
        }
      }
    }
  }


  void __thiscall IXS__Module__skipInput_004092d0(Module *module, byte *inputFileBuffer, int offset) {
    module->readPosition_0xc0 = inputFileBuffer + offset;
  }


  byte *__thiscall IXS__Module__copyFromInputFile_004092f0(Module *module, void *dest, uint len) {
    byte *result;

    memcpy(dest, module->readPosition_0xc0, len);
    result = &module->readPosition_0xc0[len];
    module->readPosition_0xc0 = result;
    return result;
  }


  byte __thiscall IXS__Module__readByte_0x409320(Module *module) {
    byte result = *module->readPosition_0xc0;
    module->readPosition_0xc0 += sizeof(byte);
    return result;
  }


  ushort __thiscall IXS__Module__readShort_0x409330(Module *module) {
    ushort result;  // make it mem alignment safe
    memcpy(&result, module->readPosition_0xc0, sizeof(ushort));
    module->readPosition_0xc0 += sizeof(ushort);
    return result;
  }


  uint __thiscall IXS__Module__readInt_0x409350(Module *module) {
    uint result;  // make it mem alignment safe
    memcpy(&result, module->readPosition_0xc0, sizeof(uint));
    module->readPosition_0xc0 += sizeof(uint);
    return result;
  }


  void __thiscall IXS__Module__copyFromInputFile_00409370(Module *module, void *dest, uint len) {
    IXS__Module__copyFromInputFile_004092f0(module, dest, len);
  }


  void __thiscall IXS__Module__writeByte_00409390(Module *module, byte value) {
    *module->writeBufferPosPtr_0xfae8 = value;
    module->writeBufferPosPtr_0xfae8 += sizeof(byte);
  }


  void __thiscall IXS__Module__writeShort_004093b0(Module *module, ushort value) {
    // make it mem alignment safe
    memcpy(module->writeBufferPosPtr_0xfae8, &value, sizeof(ushort));
    module->writeBufferPosPtr_0xfae8 += sizeof(ushort);
  }


  void __thiscall IXS__Module__writeInt_004093d0(Module *module, int value) {
    // make it mem alignment safe
    memcpy(module->writeBufferPosPtr_0xfae8, &value, sizeof(uint));
    module->writeBufferPosPtr_0xfae8 += sizeof(uint);
  }


  void __thiscall IXS__Module__writeBytes_004093f0(Module *module, byte *sourceBuf, uint len) {
    memcpy(module->writeBufferPosPtr_0xfae8, sourceBuf, len);
    module->writeBufferPosPtr_0xfae8 += len;
  }


  typedef struct Local24 Local24; // todo: explode these into function
  struct Local24 {
    struct BufInt byteInt_0x0;
    uint uint_0x4;
    int *writeBufPtr_0x8;
    struct ITEnvelope *volenv_0xc;    // below is used as a 3-entry array
    struct ITEnvelope *panenv0x10;
    struct ITEnvelope *pitchenv_0x14;
  };

  //
  // This function does not seem to be called in original player. Maybe a
  // functionality used to edit IXS files..
  //
  byte *__thiscall IXS__Module__outputTrackerFile_00409430(Module *module, uint unused) {
    Local24 local_18;

    int *writeBufferPtr = (int *) malloc(0x100000);
    module->writeBufferPosPtr_0xfae8 = (byte *) writeBufferPtr;
    local_18.writeBufPtr_0x8 = writeBufferPtr;
    // no "magic"?
    IXS__Module__writeInt_004093d0(module, 0);
    IXS__Module__writeByte_00409390(module, 0x21);
    IXS__Module__writeShort_004093b0(module, (module->impulseHeader_0x0).OrdNum_0x20);
    IXS__Module__writeShort_004093b0(module, (module->impulseHeader_0x0).InsNum_0x22);
    IXS__Module__writeShort_004093b0(module, (module->impulseHeader_0x0).SmpNum_0x24);
    IXS__Module__writeShort_004093b0(module, (module->impulseHeader_0x0).PatNum_0x26);
    IXS__Module__writeByte_00409390(module, (module->impulseHeader_0x0).GV_0x30);
    IXS__Module__writeByte_00409390(module, (module->impulseHeader_0x0).MV_0x31);
    IXS__Module__writeByte_00409390(module, (module->impulseHeader_0x0).Speed_0x32);
    IXS__Module__writeByte_00409390(module, (module->impulseHeader_0x0).Tempo_0x33);
    IXS__Module__writeBytes_004093f0(module, (byte *) (module->impulseHeader_0x0).songName_0x4, 0x1a);
    IXS__Module__writeBytes_004093f0(module, (byte *) (module->impulseHeader_0x0).ChnlVol_0x80, 0x40);
    IXS__Module__writeBytes_004093f0(module, (byte *) (module->impulseHeader_0x0).ChnlPan_0x40, 0x40);
    IXS__Module__writeBytes_004093f0
            (module, (byte *) module->ordersBuffer_0xc8, (uint) (module->impulseHeader_0x0).OrdNum_0x20);
    int j = 0;
    if ((module->impulseHeader_0x0).InsNum_0x22 != 0) {
      do {
        local_18.byteInt_0x0.b2 = 1;
        int i = 0;
        ITInstrument *ins = module->insPtrArray_0xcc[j];
        byte sample = ins->keyboard_0x40[1];
        byte *pbVar5 = ins->keyboard_0x40;
        do {
          if ((pbVar5[1] != sample) && ((int) pbVar5[0] != i)) {
            local_18.byteInt_0x0.b2 = 0;
          }
          i += 1;
          pbVar5 += 2;
        } while (i < 120);
        if ((local_18.byteInt_0x0.b2 == 0) || (sample != 0)) {
          IXS__Module__writeByte_00409390(module, 0x49);
          IXS__Module__writeShort_004093b0(module, ins->fadeout_0x14);
          IXS__Module__writeByte_00409390(module, ins->gbv_0x18);
          IXS__Module__writeByte_00409390(module, ins->dfp_0x19);
          uint *sourceBuf;
          uint sourceBufLen;
          if (local_18.byteInt_0x0.b2 == 0) {
            sourceBuf = (uint *) ins->keyboard_0x40;
            sourceBufLen = 0xf0;
          } else {
            local_18.byteInt_0x0.b4 = sample | 0x80;
            sourceBuf = (uint *) &local_18.byteInt_0x0.b3;
            sourceBufLen = 2;
            local_18.byteInt_0x0.b3 = 0;
          }
          IXS__Module__writeBytes_004093f0(module, (byte *) sourceBuf, sourceBufLen);
          ITEnvelope **envPtrArray = &local_18.volenv_0xc;
          local_18.uint_0x4 = 3;
          local_18.volenv_0xc = &ins->volenv_0x130;
          local_18.panenv0x10 = &ins->panenv_0x182;
          local_18.pitchenv_0x14 = &ins->pitchenv_0x1d4;
          do {
            ITEnvelope *env = *envPtrArray;
            if (env->flags_0x0 == 0) {
              IXS__Module__writeByte_00409390(module, 0);
            } else {
              IXS__Module__writeByte_00409390(module, env->flags_0x0);
              IXS__Module__writeByte_00409390(module, env->numNP_0x1);
              IXS__Module__writeByte_00409390(module, env->lpb_0x2);
              IXS__Module__writeByte_00409390(module, env->lpe_0x3);
              IXS__Module__writeByte_00409390(module, env->slb_0x4);
              IXS__Module__writeByte_00409390(module, env->sle_0x5);
              IXS__Module__writeBytes_004093f0(module, (byte *) env->nodePoints_0x6, (uint) env->numNP_0x1 * 3);
            }
            envPtrArray = envPtrArray + 1;
            local_18.uint_0x4 = local_18.uint_0x4 - 1;
          } while (local_18.uint_0x4 != 0);
        } else {
          IXS__Module__writeByte_00409390(module, 0x69);
        }
        j = j + 1;

        writeBufferPtr = local_18.writeBufPtr_0x8;
      } while (j < (int) (uint) (module->impulseHeader_0x0).InsNum_0x22);
    }


    j = 0;
    if ((module->impulseHeader_0x0).SmpNum_0x24 != 0) {
      do {

        if ((module->smplHeadPtrArr0_0xd0[j]->flags_0x12 & IT_SMPL) == 0) {
          IXS__Module__writeByte_00409390(module, 0x73);
        } else {
          IXS__Module__writeByte_00409390(module, 0x53);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->gvl_0x11);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->flags_0x12);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->volume_0x13);
          IXS__Module__writeInt_004093d0(module, module->smplHeadPtrArr0_0xd0[j]->length_0x30);
          IXS__Module__writeInt_004093d0(module, module->smplHeadPtrArr0_0xd0[j]->loopBegin_0x34);
          IXS__Module__writeInt_004093d0(module, module->smplHeadPtrArr0_0xd0[j]->loopEnd_0x38);
          IXS__Module__writeInt_004093d0(module, module->smplHeadPtrArr0_0xd0[j]->susLoopBegin_0x40);
          IXS__Module__writeInt_004093d0(module, module->smplHeadPtrArr0_0xd0[j]->susLoopEnd_0x44);
          IXS__Module__writeInt_004093d0(module, module->smplHeadPtrArr0_0xd0[j]->C5Speed_0x3c);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->vis_0x4c);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->vid_0x4d);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->vir_0x4e);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->vit_0x4f);
          IXS__Module__writeByte_00409390(module, module->smplHeadPtrArr0_0xd0[j]->dfp_0x2f);
          IXS__Module__writeBytes_004093f0(module, (byte *) module->smplHeadPtrArr0_0xd0[j]->name_0x14, 0xd);
        }
        j = j + 1;
      } while (j < (int) (uint) (module->impulseHeader_0x0).SmpNum_0x24);
    }
    j = 0;
    if ((module->impulseHeader_0x0).PatNum_0x26 != 0) {
      do {
        if (module->patDataPtrArray_0xdc[j] == (byte *) nullptr) {
          IXS__Module__writeByte_00409390(module, 0x70);
        } else {
          IXS__Module__writeByte_00409390(module, 0x50);
          IXS__Module__writeShort_004093b0(module, module->patHeadPtrArray_0xd8[j]->len_0x0);
          IXS__Module__writeShort_004093b0(module, module->patHeadPtrArray_0xd8[j]->rows_0x2);
          IXS__Module__writeBytes_004093f0
                  (module, (byte *) module->patDataPtrArray_0xdc[j],
                   (uint) module->patHeadPtrArray_0xd8[j]->len_0x0);
        }
        j = j + 1;
      } while (j < (int) (uint) (module->impulseHeader_0x0).PatNum_0x26);
    }

    size_t len = (int) module->writeBufferPosPtr_0xfae8 - (int) writeBufferPtr;
    module->writeBufferPosPtr_0xfae8 = (byte *) writeBufferPtr;
    IXS__Module__writeInt_004093d0(module, len);

    int *old = writeBufferPtr;
    writeBufferPtr = (int *) realloc(writeBufferPtr, len);

    if (old != writeBufferPtr) {
      // idea seems to be to reduce the originally allocated buffer "in place" to the
      // actually used size... probably this relies on a fragile implementation detail
      // and as for "realloc" a totally different buffer might be actually returned
      // here.. at least check if the buffer address stays the same and hard fail here
      // if necessary!

      fprintf(stderr, "fatal error: a fragile assumption shot him in the knee\n");
      exit(1);
    }

    return (byte *) writeBufferPtr;
  }


}