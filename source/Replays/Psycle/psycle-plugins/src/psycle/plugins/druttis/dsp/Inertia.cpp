//////////////////////////////////////////////////////////////////////
//
//				Inertia.cpp
//
//				druttis@darkface.pp.se
//
//////////////////////////////////////////////////////////////////////
#include "Inertia.h"
#include <cmath>
namespace psycle::plugins::druttis {
//////////////////////////////////////////////////////////////////////
//
//				Constructor
//
//////////////////////////////////////////////////////////////////////
Inertia::Inertia()
{
	m_length = 0;
	m_target = 0.0f;
	m_ticks = 0;
	m_decr = 1;
	m_value = 0.0f;
	m_step = 0.0f;
	m_valid = false;
}
//////////////////////////////////////////////////////////////////////
//
//				Destructor
//
//////////////////////////////////////////////////////////////////////
Inertia::~Inertia()
{
}
//////////////////////////////////////////////////////////////////////
//
//				GetLength
//
//////////////////////////////////////////////////////////////////////
int Inertia::GetLength()
{
	return m_length;
}
//////////////////////////////////////////////////////////////////////
//
//				SetLength
//
//////////////////////////////////////////////////////////////////////
void Inertia::SetLength(int length)
{
	m_length = length;
	Update();
}
//////////////////////////////////////////////////////////////////////
//
//				GetTarget
//
//////////////////////////////////////////////////////////////////////
float Inertia::GetTarget()
{
	return m_target;
}
//////////////////////////////////////////////////////////////////////
//
//				SetTarget
//
//////////////////////////////////////////////////////////////////////
void Inertia::SetTarget(float target)
{
	m_target = target;
	Update();
}
//////////////////////////////////////////////////////////////////////
//
//				GetValue
//
//////////////////////////////////////////////////////////////////////
float Inertia::GetValue()
{
	return m_value;
}
//////////////////////////////////////////////////////////////////
//
//				Update
//
//////////////////////////////////////////////////////////////////
void Inertia::Update()
{
	if(m_length > 0 && m_target != m_value)
	{
		m_ticks = m_length;
		m_decr = 1;
		m_step = (m_target - m_value) / m_ticks;
	}
	else
	{
		m_ticks = 0;
		m_decr = 0;
		m_value = m_target;
		m_step = 0;
	}
	m_valid = false;
}
//////////////////////////////////////////////////////////////////
//
//				Fill
//
//////////////////////////////////////////////////////////////////
void Inertia::Fill(float *pout, int nsamples)
{
	int amt;
	--pout;
	do
	{
		amt = Clip(nsamples);
		nsamples -= amt;
		while (amt > 1)
		{
			*++pout = Next();
			*++pout = Next();
			amt -= 2;
		}
		if (amt)
		{
			*++pout = Next();
		}
	}
	while (nsamples);
}
//////////////////////////////////////////////////////////////////
//
//				Fill & Mult. Warning. do not mix with dsp.h Fill(),
//           which has the same signature, but different meaning
//
//////////////////////////////////////////////////////////////////
void Inertia::Fill(float *pbuf, float mul, int nsamples)
{
	int amt;
	--pbuf;
	do
	{
		amt = Clip(nsamples);
		nsamples -= amt;
		while (amt > 1)
		{
			*++pbuf = Next() * mul;
			*++pbuf = Next() * mul;
			amt -= 2;
		}
		if (amt)
		{
			*++pbuf = Next() * mul;
		}
	}
	while (nsamples);
}
}